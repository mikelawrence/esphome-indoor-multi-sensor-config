# Add Smoke Alarm features
# Danger: !!!This is experimental and may not work as expected!!!
#          !!!DO NOT USE AS A PRIMARY SMOKE ALARM!!!
#          !!!Use at your own risk!!!
media_player:
  - platform: speaker
    id: !extend speaker_media_player_id
    files:
      - id: co_alarm_sound
        file: https://raw.githubusercontent.com/mikelawrence/esphome-indoor-multi-sensor-config/${ref}/media/co-alarm-four-beep.flac

binary_sensor:
  - platform: template
    name: "Alarm CO₂ Spike"
    lambda: |-
      return ((id(co2).state - id(alarm_co2_avg).state) > 4.0 * id(alarm_co2_sd).state);

sensor:
  - platform: copy
    id: alarm_co2_avg
    name: "Alarm CO₂ Avg"
    source_id: co2_internal
  - platform: copy
    id: alarm_co2_sd
    name: "Alarm CO₂ SD"
    source_id: co2_internal
    filters:
      - lambda: |-
          // max measurements to store for computing standard deviation
          const uint16_t window_size_ = 300;
          // compute and send the standard deviation after this many measurements
          const uint16_t send_every_ = 60; 

          static std::deque<float> queue_;
          static uint16_t send_at_ = 0;

          // If we have more entries in queue_ than the window_size_, 
          // then pop them off
          while (queue_.size() >= window_size_) {
            queue_.pop_front();
          }

          // add the newest reading to queue_
          queue_.push_back(x);

          if (++send_at_ >= send_every_) {
            send_at_ = 0;

            float Ex = 0.0;
            float Ex2 = 0.0;
            size_t count = 0;

            float K = queue_.front();
            
            for (auto v: queue_) {
              if (!std::isnan(v)) {
                // Welford's algorithm to avoid catastrophic cancellation
                //  - This is achieved by subtracting the oldest reading from 
                //    each measurement. If not done, then the sum of the 
                //    measurements squared and the square of the measurements 
                //    summed may be quite large, and their difference can be 
                //    problematic resulting in catastrophic cancellation

                // counts valid measurements
                count += 1;
                // sums the measurement minus the oldest reading
                Ex += v - K;
                 // sums the measurement minus the oldest reading squared
                Ex2 += pow(v-K,2);
              }
            }

            float standard_deviation = NAN;
            // If we have at least one valid reading, then compute the 
            // variance and standard deviation, otherwise it will remain NAN
            if (count) {
              float variance = (Ex2 - pow(Ex, 2)/count) / (count-1);
              // standard deviation is the square root of the variance
              standard_deviation = sqrt(variance); 
            }

            return standard_deviation;
          }
          return {};
