# Adds CO sensor using the Figaro TGS5141
substitutions:
  co_offset: "0.0"
  co_sensitivity: "2.000e-9"
  co_manufacture_date: "Not Set"
  co_serial_number: "Not Set"

logger:
  logs:
    ads1115.sensor: ERROR

esphome:
  on_boot:
    - priority: 100.0
      then:
        - lambda: |-
            // don't wait for update rate, force an immediate temperature update
            id(co_temperature).update();
    - priority: 600.0
      then:
        - lambda: |-
            // Let other parts of config know there is a CO sensor
            id(co_available_var) = true;

api:
  on_client_connected:
    then:
      - text_sensor.template.publish:
          id: co_serial_number
          state: "${co_serial_number}"
      - text_sensor.template.publish:
          id: co_manufacture_date
          state: "${co_manufacture_date}"

globals:
  - id: co_sensitivity_const
    type: double
    restore_value: false
    initial_value: ${co_sensitivity}
  - id: co_temp_calibration
    type: double[51]
    restore_value: false
    # Calibration factor based on temperature, see datasheet
    initial_value: "{ 0.7835, 0.7944, 0.8053, 0.8162, 0.8271, 0.838, 0.8489,
      0.8598, 0.8707, 0.8816, 0.8925, 0.9034, 0.9143, 0.9252, 0.9361, 0.947,
      0.9579, 0.9688, 0.9797, 0.9906, 1, 1.0075, 1.015, 1.0225, 1.03, 1.0375,
      1.045, 1.0525, 1.06, 1.0675, 1.075, 1.0825, 1.09, 1.0975, 1.105, 1.1125,
      1.12, 1.1275, 1.135, 1.1425, 1.15, 1.1575, 1.165, 1.1725, 1.18, 1.1875,
      1.195, 1.2025, 1.21, 1.2175, 1.225}"

one_wire:
  - platform: gpio
    pin: 
      number: GPIO21
      mode: INPUT_OUTPUT_OPEN_DRAIN

ads1115:
  - address: 0x48
    i2c_id: i2c1_bus
    continuous_mode: false

sensor:
  - platform: dallas_temp
    id: co_temperature
    update_interval: 60s
  - platform: ads1115
    id: co
    name: "CO"
    state_class: measurement
    device_class: carbon_monoxide
    unit_of_measurement: ppm
    update_interval: 1s
    accuracy_decimals: 0
    setup_priority: -400
    multiplexer: A0_A1
    gain: 0.512
    resolution: 16_BITS
    filters:
      - lambda: |-
          static bool error = false;
          float sensitivity = id(co_sensitivity_const);
          float cf = 1.0;
          float temp = round(id(co_temperature).state);

          if (isnan(temp)) {
            // temperature is not valid
            cf = id(co_temp_calibration)[23];
            if (!error) {
              // status not reported yet
              ESP_LOGW("co", "Board temperature is unknown, temperature calibration is using default temperature of 23Â°C");
              error = true;
            }
          } else {
            // temperature is valid
            cf = id(co_temp_calibration)[(int) temp];
            if (error) {
              // status not reported yet
              ESP_LOGW("co", "Board temperature is valid, temperature calibration is using actual temperature");
              error = false;
            }
          }
          float result = x / (sensitivity * 133000.0 / cf);
          ESP_LOGV("co", "Sensitivity=%0.9f, temp=%0.0f, cf=%0.9f, result=%0.1f"
            , sensitivity * 133000.0, temp, cf, result);
          return result;
      - offset: ${co_offset}
      - clamp:
          min_value: 0.0
      - sliding_window_moving_average:
          window_size: 180
          send_every: 1
      - throttle: 60s
      - skip_initial: 2

  - platform: copy
    id: co_internal
    source_id: co

  - platform: copy
    id: co_5min_avg
    source_id: co
    filters:
      - exponential_moving_average:
          # 1 / (samples + 1) = 1 / 6
          alpha: 0.16666667
          send_every: 1
    on_value:
      then:
        - lambda: |-
            if (x > 400.0) {
              id(co_400ppm_alarm_var) = true;
            }
            if (x < 360.0) {
              id(co_400ppm_alarm_var) = false;
            }
            if (!id(co_400ppm_alarm_var) &&
                !id(co_150ppm_alarm_var) &&
                !id(co_70ppm_alarm_var)) {
              id(co_alarm_var) = false;
            } else {
              id(co_alarm_var) = true;
            }
  - platform: copy
    id: co_10min_avg
    source_id: co
    filters:
      - exponential_moving_average:
          # 1 / (samples + 1) = 1 / 11
          alpha: 0.09090909
          send_every: 1
    on_value:
      then:
        - lambda: |-
            if (x > 150.0) {
              id(co_150ppm_alarm_var) = true;
            }
            if (x < 135.0) {
              id(co_150ppm_alarm_var) = false;
            }
            if (!id(co_400ppm_alarm_var) &&
                !id(co_150ppm_alarm_var) &&
                !id(co_70ppm_alarm_var)) {
              id(co_alarm_var) = false;
            } else {
              id(co_alarm_var) = true;
            }
  - platform: copy
    id: co_60min_avg
    source_id: co
    filters:
      - exponential_moving_average:
          # 1 / (samples + 1) = 1 / 61
          alpha: 0.01639344
          send_every: 1
    on_value:
      then:
        - lambda: |-
            if (x > 70.0) {
              id(co_70ppm_alarm_var) = true;
            }
            if (x < 63.0) {
              id(co_70ppm_alarm_var) = false;
            }
            if (!id(co_400ppm_alarm_var) &&
                !id(co_150ppm_alarm_var) &&
                !id(co_70ppm_alarm_var)) {
              id(co_alarm_var) = false;
            } else {
              id(co_alarm_var) = true;
            }
  - platform: copy
    id: co_8hr_avg
    source_id: co
    filters:
      - exponential_moving_average:
          # 1 / (samples + 1) = 1 / 481
          alpha: 0.00207900
          send_every: 1
    on_value:
      then:
        - lambda: |-
            if (x > 10.0) {
              id(co_warning_var) = true;
            }
            if (x < 9.0) {
              id(co_warning_var) = false;
            }

text_sensor:
  - platform: template
    name: "CO Serial Number"
    id: co_serial_number
    entity_category: diagnostic
    update_interval: never
    lambda: 'return {""};'
  - platform: template
    name: "CO Manufacture Date"
    id: co_manufacture_date
    entity_category: diagnostic
    update_interval: never
    lambda: 'return {""};'
